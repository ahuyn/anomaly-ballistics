get_config = ballistics_mcm.get_config
-- track and store armor reductions
local bone_reduced_armor = {}

local ini_ammo = ini_file("items\\ammo\\importer.ltx")

-- not all bone ids are represented in the table - this covers the rest
Bone_IDs = {
    [2]  =	"bip01_pelvis",
    [3]  =	"bip01_l_thigh",
    [4]  =	"bip01_l_calf",
    [5]  =	"bip01_l_foot",
    [7]  =	"bip01_r_thigh",
    [8]  =	"bip01_r_calf",
    [9]  =	"bip01_r_foot",
    [11] =	"bip01_spine",
    [12] =	"bip01_spine1",
    [13] =	"bip01_spine2",
    -- head
    [14] =	"bip01_neck", 
    [15] =	"bip01_head",
    [16] =	"eye_left",
    [17] =	"eye_right",
    [18] =	"eyelid_1",
    [19] =	"jaw_1",
    -- endhead
    [20] =	"bip01_l_clavicle",
    [21] =	"bip01_l_upperarm",
    [22] =	"bip01_l_forearm",
    [23] =	"bip01_l_forearm",
    [33] =	"bip01_r_clavicle",
    [34] =	"bip01_r_upperarm",
    [35] =	"bip01_r_forearm",
    [36] =	"bip01_r_forearm",
    }

head_bones = {
        
    [14] =	"bip01_neck", 
    [15] =	"bip01_head",
    [16] =	"eye_left",
    [17] =	"eye_right",
    [18] =	"eyelid_1",
    [19] =	"jaw_1",
}

function print_dbg(text, ...) 
	if get_config("debug") then
		printf("ballistics | %s | " .. text, time_global(), ...)
	end
end

-- checking if actor shot the gun and if gun is gun
function validate_hit(shit)
    if shit.draftsman and shit.draftsman:id() ~= AC_ID then return end
	if bone_id == 65535 then return end
	if shit.power >= 50 then return end
	local shooter = shit.draftsman
	local wpn = level.object_by_id(shit.weapon_id)
	if not wpn or IsGrenade(wpn) or (not IsWeapon(wpn)) then return end
	local sec = wpn:section()
	if ini_sys:r_string_ex(sec, "class") == "S_EXPLO" then return end
	if IsItem("fake_ammo_wpn",sec) then return end
    ammo_map = utils_item.get_ammo(nil, shit.weapon_id)
    local ammo = ammo_map[wpn:get_ammo_type() + 1]
    return {
        ["weapon"] = wpn, 
        ["ammo"] = ammo,
        ["section"] = sec
    } -- returning stuff we parsed, so we don't parse it again
end

local bone_cache = {}
-- pull npc bone sections based on the outfit they wear
-- if not there, fall back to a standard armor based on rank
-- will be deprecated
function get_npc_bone_armor(npc, visual, bone_id)
    -- local npc_id = npc:id()
    -- if custom_bone_data[npc_id] and custom_bone_data[npc_id][bone_id] then
    --     return custom_bone_data[npc_id][bone_id]
    -- end
    -- local visual = visual or npc:get_visual_name()
	-- local tbl = death_manager.get_outfit_by_npc_visual(visual)
    -- local outfit_sec = tbl and tbl[1] or "scientific_outfit"
    -- local helmet_sec = tbl and tbl[2]
    -- local outfit_bones = SYS_GetParam(0, outfit_sec, "bones_koeff_protection")
    -- if head_bones[bone_id] then
    --     -- try to pull helmet
    --     local helm_bones = helmet_sec and SYS_GetParam(0, helmet_sec, "bones_koeff_protection") or outfit_bones
    --     if not bone_cache[helm_bones] then bone_cache[helm_bones] = {} end
    --     if not bone_cache[helm_bones][bone_id] then
    --         helm_bone_armor = SYS_GetParam(0, helm_bones, head_bones[bone_id])
    --         helm_bone_armor = str_explode(helm_bone_armor, ",")
    --         bone_cache[helm_bones][bone_id] = tonumber(helm_bone_armor[2])
    --     end
    --     return bone_cache[helm_bones][bone_id]
    -- else
    --     if not bone_cache[outfit_bones][bone_id] then
    --         bone_armor = SYS_GetParam(0, outfit_bones, Bone_IDs[bone_id])
    --         bone_armor = str_explode(helm_bone_armor, ",")
    --         bone_cache[outfit_bones][bone_id] = tonumber(bone_armor[2])
    --     end
    --     return bone_cache[helm_bones][bone_id]
    -- end
end

-- use lucy custom func
function get_npc_bone_armor_l(npc, bone_id)
    return npc:get_bone_protection(bone_id)
end

function get_ammo_data(ammo_sec)
    if ini_ammo:section_exist(ammo_sec) then
        local proc = ini_ammo:r_string_ex(ammo_sec, "handler") or "ballistics.calculate_damage"
        proc = str_explode(proc, "%.")
        return {
            sec     = ammo_sec,
            k_hit   = ini_ammo:r_float_ex(ammo_sec, "hit") or 1,
            k_ap    = ini_ammo:r_float_ex(ammo_sec, "ap") or 0,
            processor = proc
        }
    end
end

-- Provide a damage modifier based on distance, adjusted by bullet velocity and flatness
-- todo: factor in flatness modifiers
function modify_distance(shooter, npc, air_res, vel_data)
    local npc_pos = npc:position()
	local shooter_pos = shooter:position()
	local dist = npc_pos:distance_to(shooter_pos)

    return clamp((vel_data.true_vel/vel_data.base_vel) / ( 1 + dist / 200 * ( air_res * 0.5 / ( 1 - air_res + 0.1 )))
    , 0, 1)
end


local stalker_damage = {}
local custom_bone_data = {}
-- pull the bone_mult from [stalker_damage] section
function npc_bone_mult(bone_id)
    local damage_mult = stalker_damage[bone_id]
    if damage_mult then return damage_mult 
    else
        -- pull from data and cache
        local bone_name = Bone_IDs[bone_id] or "bip01_spine"
        local damages = SYS_GetParam(0, "stalker_damage", bone_name)
        damages = str_explode(damages, ",")
        stalker_damage[bone_id] = tonumber(damages[1])
        return damages[1]
    end

end

-- Used to modify the custom values of a stalker's bone armors (to account for reductions, etc)
function modify_bone(npc, bone_id, val)
    local npc_id = npc:id()
    if not custom_bone_data[npc_id] then custom_bone_data[npc_id] = {} end
    custom_bone_data[npc_id][bone_id] = val
end

local cur_wep_data = {}
-- check and update current weapon to cache hit power and velocity
function actor_on_weapon_before_fire(flags)
    local current_wpn = db.actor:active_item()
    -- cache
    if (not cur_wep_data.id or cur_wep_data.id ~= current_wpn:id()) and (IsWeapon(obj) and (not IsItem("fake_ammo_wpn",obj:section()))) then
        local sec = SYS_GetParam(0, current_wpn:section(),"parent_section") or current_wpn:section()
        cur_wep_data.id = current_wpn:id()
        cur_wep_data.hit = ui_wpn_params.read_float(sec, "", "hit_power")
        cur_wep_data.base_vel = SYS_GetParam(2, sec, "bullet_speed")
        local vel_add = 0
        local upgrades = utils_item.get_upgrades_installed(current_wpn)
        for _, upgrade in pairs(upgrades) do
            local section = ini_sys:r_string_ex(upgrade, "section")
            local speed_adj = ini_sys:r_string_ex(section,"bullet_speed")
            if speed_adj then
                local op = string.sub(speed_adj, 1, 1)
                local val = tonumber(string.sub(speed_adj, 2))
    
                vel_add = op == "+" and vel_add + val or vel_add - val
            end
        end
        cur_wep_data.true_vel = cur_wep_data.base_vel + vel_add
    end
end

-- Default means to calculate damage
function calculate_damage(npc, s_hit, data, is_human)
    if not is_human then return s_hit end
    local base_hp = data.hit.base_power
    base_hp = base_hp * data.ammo.k_hit
    if get_config("velocity") then
        local air_res = SYS_GetParam(2, data.hit.ammo, "k_air_resistance") or 0.05
        -- todo implement properly
        -- base_hp = base_hp * modify_distance(s_hit.draftsman, npc, air_res, cur_wep_data)
    end
    local bone_armor_rounded = math.floor(data.bone.armor * 10)
    local armor_tier = math.floor(bone_armor_rounded)
    local armor_frac = math.fmod(bone_armor_rounded,1)

    local ap_rounded = (data.ammo.k_ap * 10)
    local ap_tier = math.floor(ap_rounded)
    local ap_frac = math.fmod(ap_rounded,1)

    local diff = ap_tier - armor_tier
    -- if the tiers match, modify damage by difference in fractional
    if diff == 0 then -- match, reduce dmg by up to the fractional diff
        print_dbg("Tier Match")
        local frac_diff = clamp(armor_frac - ap_frac, 0, 0.5)
        base_hp = base_hp * (1 - frac_diff)
        -- unlisted, but if bullets are 1-2 tiers above then deal full dmg
    elseif diff == -1 then -- armor slightly tougher, halved
        print_dbg("Armor > AP 1")
        base_hp = base_hp * 0.5
    elseif diff > 2 then -- overpenetration - reduce by up to 80%
        print_dbg("AP > Armor 2")
        base_hp = base_hp * (1 - 0.3*(diff - 2))
    elseif diff < -1 then -- bullets bounce off lel
        print_dbg("Armor > AP 1")
        base_hp = base_hp * 0.01 * (diff + 5)
    end

    -- Apply bone mult
    base_hp = base_hp * data.bone.mult

    print_dbg("Bone: %s. BA: %s. BM: %s. AP: %s. Original: %s. Base hit: %s. Final hit: %s", data.bone.name, data.bone.armor, data.bone.mult, data.ammo.k_ap, s_hit.power, data.hit.base_power, base_hp)
    s_hit.power = base_hp
    return s_hit
end



-- for the most part calculations will be deferred to function-specifics for each ammo type
-- here we just expose a bunch of util functions
function npc_on_before_hit(npc,s_hit,bone_id)
    local valid_hit_data = validate_hit(s_hit)
    if not (valid_hit_data) then -- no data, so we don't care about the hit
        return false 
    end
    local wpn = valid_hit_data.weapon
    local ammo = valid_hit_data.ammo
    local sec = valid_hit_data.section
    -- get ammo information with custom hit, ap
    local ammo_data = get_ammo_data(ammo)
    if not ammo_data then return false end
    print_dbg("Valid ammo %s used, providing custom hit modifier %s, AP %s", ammo, ammo_data.k_hit, ammo_data.k_ap)
    local wpn_hit_power = ui_wpn_params.read_float(sec, "", "hit_power")
    -- reduce base hit power by distance and velocity
    local hit_data = {
        base_power = wpn_hit_power,
        wpn = wpn
    }
    -- get bone data
    local bone_data = {
        id = bone_id,
        name = Bone_IDs[bone_id],
        armor = npc:get_bone_protection(bone_id),
        mult = npc_bone_mult(bone_id)
    }
    local data = {
        hit = hit_data,
        bone = bone_data,
        ammo = ammo_data
    }
    -- pass to the ammo processor
    -- return value should be the new hit
    local func = ammo_data.processor
    if func and func[1] and func[2] and _G[func[1]] and _G[func[1]][func[2]] then
        s_hit = _G[func[1]][func[2]](npc, s_hit, data, true)
    end

    return {
        ["shit"] = s_hit,
        ["bone_id"] = bone_id
    } -- just returning something for now
end

function monster_on_before_hit(monster,s_hit,bone_id)
    local valid_hit_data = validate_hit(s_hit)
    if not (valid_hit_data) then 
        return false 
    end
    local wpn = valid_hit_data.weapon
    local sec = valid_hit_data.section
    printf("Actor hit monster [%s] with [%s]", monster:section(), sec)
    return {
        ["shit"] = s_hit,
        ["bone_id"] = bone_id
    }
end

-- Overriding hit callbacks so our custom hits can communicate with other scripts
local flags = { ret_value = true }

_G.CAI_Stalker__BeforeHitCallback = function(npc,shit,bone_id)
    local s_hit = shit
    flags.ret_value = true
    local custom_hit = npc_on_before_hit(npc,s_hit,bone_id)
    if custom_hit then
        SendScriptCallback("npc_on_before_hit",npc,custom_hit.shit,custom_hit.bone_id, flags)
        if flags.ret_value then
            npc:set_health_ex(npc.health - custom_hit.shit.power)
            shit.power = 0.0001 -- removing engine stuff
        end
    else
        SendScriptCallback("npc_on_before_hit",npc,shit,bone_id,flags)
    end
	return flags.ret_value
end

_G.CBaseMonster__BeforeHitCallback = function(monster,shit,bone_id)
	local s_hit = shit
    flags.ret_value = true
    local custom_hit = monster_on_before_hit(monster,s_hit,bone_id)
    if custom_hit then
        SendScriptCallback("monster_on_before_hit",monster,custom_hit.shit,custom_hit.bone_id, flags)
        if flags.ret_value then
            monster:set_health_ex(monster.health - custom_hit.shit.power)
            shit.power = 0.0001
        end
    else
        SendScriptCallback("monster_on_before_hit",monster,shit,bone_id,flags)
    end
	return flags.ret_value
end