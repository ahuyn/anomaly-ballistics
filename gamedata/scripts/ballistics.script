get_config = ballistics_mcm.get_config
-- track and store armor reductions
local bone_reduced_armor = {}

ini_ammo = ini_file("items\\ammo\\importer.ltx")

-- not all bone ids are represented in the table - this covers the rest
Bone_IDs = {
    [2]  =	"bip01_pelvis",
    [3]  =	"bip01_l_thigh",
    [4]  =	"bip01_l_calf",
    [5]  =	"bip01_l_foot",
    [7]  =	"bip01_r_thigh",
    [8]  =	"bip01_r_calf",
    [9]  =	"bip01_r_foot",
    [11] =	"bip01_spine",
    [12] =	"bip01_spine1",
    [13] =	"bip01_spine2",
    -- head
    [14] =	"bip01_neck", 
    [15] =	"bip01_head",
    [16] =	"eye_left",
    [17] =	"eye_right",
    [18] =	"eyelid_1",
    [19] =	"jaw_1",
    -- endhead
    [20] =	"bip01_l_clavicle",
    [21] =	"bip01_l_upperarm",
    [22] =	"bip01_l_forearm",
    [23] =	"bip01_l_forearm",
    [33] =	"bip01_r_clavicle",
    [34] =	"bip01_r_upperarm",
    [35] =	"bip01_r_forearm",
    [36] =	"bip01_r_forearm",
    }

head_bones = {
        
    [14] =	"bip01_neck", 
    [15] =	"bip01_head",
    [16] =	"eye_left",
    [17] =	"eye_right",
    [18] =	"eyelid_1",
    [19] =	"jaw_1",
}

function print_dbg(text, ...) 
	if get_config("debug") then
		printf("ballistics | %s | " .. text, time_global(), ...)
	end
end

-- checking if actor shot the gun and if gun is gun
function validate_hit(shit)
    if shit.draftsman and shit.draftsman:id() ~= AC_ID then return end
	if bone_id == 65535 then return end
	if shit.power >= 50 then return end
	local shooter = shit.draftsman
	local wpn = level.object_by_id(shit.weapon_id)
	if not wpn or IsGrenade(wpn) or (not IsWeapon(wpn)) then return end
	local sec = wpn:section()
	if ini_sys:r_string_ex(sec, "class") == "S_EXPLO" then return end
	if IsItem("fake_ammo_wpn",sec) then return end
    ammo_map = utils_item.get_ammo(nil, shit.weapon_id)
    local ammo = ammo_map[wpn:get_ammo_type() + 1]
    return {
        ["weapon"] = wpn, 
        ["ammo"] = ammo,
        ["section"] = sec
    } -- returning stuff we parsed, so we don't parse it again
end

local bone_cache = {}
-- pull npc bone sections based on the outfit they wear
-- if not there, fall back to a standard armor based on rank
-- will be deprecated
function get_npc_bone_armor(npc, visual, bone_id)
    -- local npc_id = npc:id()
    -- if custom_bone_data[npc_id] and custom_bone_data[npc_id][bone_id] then
    --     return custom_bone_data[npc_id][bone_id]
    -- end
    -- local visual = visual or npc:get_visual_name()
	-- local tbl = death_manager.get_outfit_by_npc_visual(visual)
    -- local outfit_sec = tbl and tbl[1] or "scientific_outfit"
    -- local helmet_sec = tbl and tbl[2]
    -- local outfit_bones = SYS_GetParam(0, outfit_sec, "bones_koeff_protection")
    -- if head_bones[bone_id] then
    --     -- try to pull helmet
    --     local helm_bones = helmet_sec and SYS_GetParam(0, helmet_sec, "bones_koeff_protection") or outfit_bones
    --     if not bone_cache[helm_bones] then bone_cache[helm_bones] = {} end
    --     if not bone_cache[helm_bones][bone_id] then
    --         helm_bone_armor = SYS_GetParam(0, helm_bones, head_bones[bone_id])
    --         helm_bone_armor = str_explode(helm_bone_armor, ",")
    --         bone_cache[helm_bones][bone_id] = tonumber(helm_bone_armor[2])
    --     end
    --     return bone_cache[helm_bones][bone_id]
    -- else
    --     if not bone_cache[outfit_bones][bone_id] then
    --         bone_armor = SYS_GetParam(0, outfit_bones, Bone_IDs[bone_id])
    --         bone_armor = str_explode(helm_bone_armor, ",")
    --         bone_cache[outfit_bones][bone_id] = tonumber(bone_armor[2])
    --     end
    --     return bone_cache[helm_bones][bone_id]
    -- end
end

-- use lucy custom func
function get_npc_bone_armor_l(npc, bone_id)
    return npc:get_bone_protection(bone_id)
end

function get_handler(ammo_sec)
    if ini_ammo:section_exist(ammo_sec) then
        local proc = ini_ammo:r_string_ex(ammo_sec, "handler") or "ballistic_handlers.calculate_damage"
        proc = str_explode(proc, "%.")
        return proc
    end
end

-- Provide a damage modifier based on distance, adjusted by bullet velocity and flatness
-- todo: factor in flatness modifiers
function modify_distance(shooter, npc, air_res)
    local npc_pos = npc:position()
	local shooter_pos = shooter:position()
	local dist = npc_pos:distance_to(shooter_pos)

    return clamp(1 / ( 1 + dist / 200 * ( air_res * 0.5 / ( 1 - air_res + 0.1 )))
    , 0, 1)
end


local stalker_damage = {}
-- pull the bone_mult from [stalker_damage] section, cache the values to prevent excessive stringsplitting
function npc_bone_mult(bone_id)
    local damage_mult = stalker_damage[bone_id]
    if damage_mult then return damage_mult 
    else
        -- pull from data and cache
        local bone_name = Bone_IDs[bone_id] or "bip01_spine"
        local damages = SYS_GetParam(0, "stalker_damage", bone_name)
        damages = str_explode(damages, ",")
        stalker_damage[bone_id] = tonumber(damages[1])
        return damages[1]
    end

end

local custom_bone_data = {}
-- Used to modify the custom values of a stalker's bone armors (to account for reductions, etc)
function modify_bone(npc, bone_id, val)
    local npc_id = npc:id()
    if not custom_bone_data[npc_id] then custom_bone_data[npc_id] = {} end
    custom_bone_data[npc_id][bone_id] = val
end

-- Pull bone protection for a given NPC's bone. Can use custom bone data.
function npc_bone_protection(npc, bone_id)
    local id = npc:id()
    if custom_bone_data[id] and custom_bone_data[id][bone_id] then return custom_bone_data[id][bone_id] 
    else
        return npc:get_bone_protection(bone_id)
    end
end

local cur_wep_data = {}
-- check and update current weapon to cache hit power and velocity
function actor_on_weapon_before_fire(flags)
    local current_wpn = db.actor:active_item()
    -- cache
    if (not cur_wep_data.id or cur_wep_data.id ~= current_wpn:id()) then
        if (IsWeapon(obj) and (not IsItem("fake_ammo_wpn",obj:section()))) then
            local sec = SYS_GetParam(0, current_wpn:section(),"parent_section") or current_wpn:section()
            cur_wep_data.id = current_wpn:id()
            base_vel = SYS_GetParam(2, sec, "bullet_speed")
            local vel_add = 0
            local upgrades = utils_item.get_upgrades_installed(current_wpn)
            for _, upgrade in pairs(upgrades) do
                local section = ini_sys:r_string_ex(upgrade, "section")
                local speed_adj = ini_sys:r_string_ex(section,"bullet_speed")
                if speed_adj then
                    local op = string.sub(speed_adj, 1, 1)
                    local val = tonumber(string.sub(speed_adj, 2))
        
                    vel_add = op == "+" and vel_add + val or vel_add - val
                end
            end
            cur_wep_data.vel_mod = vel_add/base_vel
            printf("Stored velocity mod %s for wpn %s", cur_wep_data.vel_mod, current_wpn:section())
        else
            -- clear
            cur_wep_data.id = 0
            cur_wep_data.vel_mod = 0
        end
    end
end

-- return the velocity modifier for the current weapon, or 1
function get_cur_vel(id)
    return cur_wep_data.id == id and cur_wep_data.vel_mod or 0
end


-- for the most part calculations will be deferred to function-specifics for each ammo type
-- Generically it will call a function specified in config. Function determines how damage is applied.
-- Return false or nothing in order to 
-- here we just expose a bunch of util functions
function npc_on_before_hit(npc,s_hit,bone_id)
    local valid_hit_data = validate_hit(s_hit)
    if not (valid_hit_data) then -- no data, so we don't care about the hit
        return false 
    end
    local wpn = valid_hit_data.weapon
    local ammo = valid_hit_data.ammo
    local sec = valid_hit_data.section
    -- get ammo information with custom hit, ap
    local func = get_handler(ammo)
    if not func then return false end
    print_dbg("Applying custom hit for %s using function %s.%s. Prev hit power %s", ammo, func[1], func[2], s_hit.power)
    -- pass to the ammo processor
    -- return value should be the new hit
    if func and func[1] and func[2] and _G[func[1]] and _G[func[1]][func[2]] then
        ret_val = _G[func[1]][func[2]](npc, s_hit, bone_id, valid_hit_data, true)
        if ret_val then s_hit = ret_val end
    end

    return {
        ["shit"] = s_hit,
        ["bone_id"] = bone_id
    } -- just returning something for now
end

function monster_on_before_hit(monster,s_hit,bone_id)
    local valid_hit_data = validate_hit(s_hit)
    if not (valid_hit_data) then 
        return false 
    end
    local wpn = valid_hit_data.weapon
    local sec = valid_hit_data.section
    printf("Actor hit monster [%s] with [%s]", monster:section(), sec)
    return {
        ["shit"] = s_hit,
        ["bone_id"] = bone_id
    }
end

-- Overriding hit callbacks so our custom hits can communicate with other scripts
local flags = { ret_value = true }

_G.CAI_Stalker__BeforeHitCallback = function(npc,shit,bone_id)
    local s_hit = shit
    flags.ret_value = true
    local custom_hit = npc_on_before_hit(npc,s_hit,bone_id)
    if custom_hit then
        SendScriptCallback("npc_on_before_hit",npc,custom_hit.shit,custom_hit.bone_id, flags)
        if flags.ret_value then
            npc:set_health_ex(npc.health - custom_hit.shit.power)
            shit.power = 0.0001 -- removing engine stuff
        end
    else
        SendScriptCallback("npc_on_before_hit",npc,shit,bone_id,flags)
    end
	return flags.ret_value
end

_G.CBaseMonster__BeforeHitCallback = function(monster,shit,bone_id)
	local s_hit = shit
    flags.ret_value = true
    local custom_hit = monster_on_before_hit(monster,s_hit,bone_id)
    if custom_hit then
        SendScriptCallback("monster_on_before_hit",monster,custom_hit.shit,custom_hit.bone_id, flags)
        if flags.ret_value then
            monster:set_health_ex(monster.health - custom_hit.shit.power)
            shit.power = 0.0001
        end
    else
        SendScriptCallback("monster_on_before_hit",monster,shit,bone_id,flags)
    end
	return flags.ret_value
end

function on_game_start()
    RegisterScriptCallback("actor_on_weapon_before_fire", actor_on_weapon_before_fire)
end