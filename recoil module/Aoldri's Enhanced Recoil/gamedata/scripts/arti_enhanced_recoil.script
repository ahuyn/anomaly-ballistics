-- Rip of the enhanced recoil effects with wildcarding support and ammo support
get_config = ballistics_mcm.get_config
print_dbg = ballistics_mcm.print_dbg

local ini_eff = ini_file("plugins\\recoil\\importer.ltx")
local ini_ammo_eff = ini_file("plugins\\ammo_recoil\\importer.ltx")

local wpn_fx = {}
local function parse_anims(sec)
	local sec_p = ini_sys:r_string_ex(sec,"parent_section") or sec
	
	if wpn_fx[sec_p] and (sec ~= sec_p) then
		wpn_fx[sec] = wpn_fx[sec_p]
		
	elseif ini_eff:section_exist(sec_p) then
		local tbl = {}
		
		-- parse strength
		tbl.s = {}
		local s = ini_eff:r_string_ex(sec_p,"s")
		local _s = str_explode(s,",")
		for i=1,#_s do
			tbl.s[#tbl.s + 1] = tonumber(_s[i])
		end
		
		-- parse strength randomizer
		tbl.r = ini_eff:r_float_ex(sec_p,"r")
		
		-- parse anm
		tbl.e = {}
		local e = ini_eff:r_string_ex(sec_p,"e")
		local _e = str_explode(e,",")
		for i=1,#_e do
			local __e = str_explode(_e[i],":")
			for j=1,#__e do
				__e[j] = tonumber(__e[j])
			end
			tbl.e[#tbl.e + 1] = __e
		end
		
		-- parse ppe
		tbl.p = {}
		local p = ini_eff:r_string_ex(sec_p,"p")
		if p and p ~= "" then
			for k,v in string.gmatch(p, "([%w_%-%s%.]+)=([%w_%-%s%.]+)") do
				tbl.p[k] = tonumber(v)
			end
		end
		
		if (not wpn_fx[sec_p]) and (sec ~= sec_p) then
			wpn_fx[sec_p] = tbl
		end
		
		wpn_fx[sec] = tbl
		--utils_data.print_table(wpn_fx[sec])
		
	else
		wpn_fx[sec] = true
		--printf("not recoil effect for [%s]", sec)
	end
end

local is_looking = false
local is_firing = false

local shotc = 1  -- Counts the number of shots in a consecutive burst
local shott = 0  -- Used to determin how far aparts shots can be to be considered part of the same burst
local kick_t = 0 -- Time when kick stops
local fov_r = 1
function shoot_effect(obj, sect)

	if shott and (shott < time_global()) then
		shotc = 1
		shott = nil
	end
    -- grab ammo recoil base and modify by recoil upgrades     
    local ammo_list = utils_item.get_ammo(sect, obj:id())
    local ammo_type = ammo_list[obj:get_ammo_type() + 1]
    local recoil_base = ini_ammo_eff:r_float_ex(ammo_type, "recoil") or 1
    recoil_base = recoil_base * ballistics_utils.get_recoil(obj:id())

    local anims = {}
	local s = wpn_fx[sect].s
	local sc = #s

	if sc > 1 then
		if wpn_fx[sect].r == 1 then
			s = s[math.random(#s)]
		elseif wpn_fx[sect].r == 2 then
			if shotc == 1 then
				s = s[1]
			else
				s = s[math.random(2,#s)]
			end
		else
			sc = shotc <= sc and shotc or (sc > 2 and math.random(sc-1,sc)) or sc
			s = s[sc]
		end
	else
		s = s[1]
	end
	for i,v in pairs(wpn_fx[sect].e) do
		local cnt,r = math.modf(v[1]*fov_r)
		if r ~= 0 and cnt > 4 then --fmb
			cnt = cnt-cnt*math.random(0,r*100)/100 --fmb
			cnt,r = math.modf(cnt)
		end

		if r ~= 0 and math.random() < r then
			cnt = cnt+1
		end

		if cnt > 0 then
			table.insert(anims,{e = i, d = v[2] or math.random(0,1), c = cnt})
		end
	end
	
	for i,a in ipairs(anims) do
		local n = string.format([[shoot\s%s_e%s_%s.anm]], s, 2, 0)
		for ii=1,a.c do
			-- printf("N: " .. n)
			level.add_cam_effector(n,math.random(5000, 8000),false,"", 0, false, recoil_base*0.1)
		end
		-- printf("----")
	end
	-- printf("====")

	-- local n = string.format([[shoot\s%s_e%s_%s.anm]], s, 2, 0)
	-- level.add_cam_effector(n,math.random(5000, 8000),false,"", 0, false, recoil_base)

	for k,v in pairs(wpn_fx[sect].p) do
		local eid = math.random(5000,8000)
		level.add_pp_effector(string.format([[shoot\%s_s%s.ppe]],k,s), eid, false)
		if v > 0 then
			level.set_pp_effector_factor(eid,v)
		end
	end

	recoil_camera(obj, recoil_base, shotc, s)
    shotc = shotc+1
	shott = time_global()+200 -- adjust based on gun rpm / handling?
end

function camera_effect(obj, recoil_base, h_recoil, strength)
	-- printf("h_recoil: " .. h_recoil)
	-- Assumes h_recoil ranges from -1 to 1
	local n = string.format([[shoot\s%s_e%s_%s.anm]], strength, 0, h_recoil < 0 and 0 or 1)
	level.add_cam_effector(n,math.random(5000, 8000),false,"", 0, false, recoil_base*math.abs(h_recoil))
end

-- Invoked whenever a shot is fired and enhanced recoil applies.
-- Patch this to modify the magnitude based on the weapon, ammo and shots fired.
-- What this does:
-- Value is applied as the recoil  
function recoil_multiplier(base, wpn, ammo_sec, shotc)
	return base
end

local v_factor = 0.5
local v_recoil = 0

-- local horizontal_base = 0
local h_recoil = 0
local h_factor = 0.4
-- local mult_table = {
-- 	[1] = 0,
-- 	[2] = 0,
-- 	[3] = 0,
-- 	[4] = 0,
-- 	[5] = 0,
-- 	[6] = 0,

-- }
function recoil_camera(obj, recoil_base, shotc, s)
	-- local mult = (clamp((5 - shotc)/5, 0, 1)) * s or 0
	local sec = obj:section()
	local sec_p = ini_sys:r_string_ex(sec,"parent_section") or sec
	local mult_table = ini_eff:r_list(sec_p, "kick_recoil", "0, 0, 0, 0, 0, 0")

	local mult = tonumber(mult_table[shotc]) or 0
	if db.actor.actor_look_at_point and db.actor.actor_stop_look_at_point then
		-- printf("Recoil mult is %s, shots fired %s", mult, shotc)
		local actor_position = device().cam_pos
		local actor_direction = device().cam_dir	
		local is_zoomed = obj:cast_Weapon():IsZoomed()
		
		-- Horizontal
		-- Base Horizontal Recoil
		local horizontal_base = is_zoomed == 1 and SYS_GetParam(2, sec, "zoom_cam_step_angle_horz") or SYS_GetParam(2, sec, "cam_step_angle_horz")
		horizontal_base = horizontal_base * (recoil_base)

		-- Randomness
		local h_recoil_rnd = (math.random()-0.5)
		-- local h_recoil_rnd = math.random(-1, 1)
		h_recoil = h_recoil_rnd * horizontal_base * h_factor
		
		-- Rotate camera left-right
		actor_direction = vector_rotate_y(actor_direction, h_recoil)
		camera_effect(obj, recoil_base, h_recoil_rnd*2, s)
		
		-- Vertical
		local vertical_base = is_zoomed == 1 and SYS_GetParam(2, sec, "zoom_cam_dispersion") or SYS_GetParam(2, sec, "cam_dispersion")
		vertical_base = vertical_base * (recoil_base)

		local zoom_factor = obj:cast_Weapon():GetZoomFactor() 
		local zoom_kick_factor = is_zoomed and zoom_factor ~= 0 and 5*(1/zoom_factor) or 1
		v_recoil = vertical_base * zoom_kick_factor * mult * v_factor
		actor_direction.y = clamp(actor_direction.y + (v_recoil), -0.999, 0.999)

		-- printf("recoil_base: " .. recoil_base)
		kick_t = time_global()+(math.max(50, 100*recoil_base)) -- need to adjust for when scoped in
		if not is_looking then
			db.actor:actor_look_at_point(vector():set(actor_position):add(actor_direction:mul(10000)))
			is_looking = true
			demonized_time_events.CreateTimeEvent("stoplook", 1, 0, function()
				local active_item = db.actor:active_item()
				if not active_item then 
					return true 
				end

				if not is_looking then
					db.actor:actor_stop_look_at_point()
					return true
				end
				if active_item:get_state() == 5 then
					db.actor:actor_stop_look_at_point()
					if kick_t < time_global() then
						is_looking = false
						return true
					end

					actor_direction = device().cam_dir
					actor_direction.y = clamp(actor_direction.y + (v_recoil), -0.999, 0.999)
					actor_direction = vector_rotate_y(actor_direction, h_recoil)
					db.actor:actor_look_at_point(vector():set(device().cam_pos):add(actor_direction:mul(10000)))
					return false
				end

				is_looking = false
				db.actor:actor_stop_look_at_point()

				return true
			end, horizontal_base)
		end
	end

	-- printf("shotc=" .. shotc)
	-- if shotc >=  6 then
	-- 	is_looking = false
	-- end
end

function Update_Shooting(obj, wpn, ammo_elapsed, grenade_elapsed, ammo_type, grenade_type)
	if (obj:id() ~= AC_ID) then
		return
	end

	local wpn_obj = utils_item.item_is_fa(wpn) and wpn
	if wpn_obj then
		local sec = wpn_obj:section()
		
		if (not wpn_fx[sec]) then
			parse_anims(sec)
		end
		
		if (wpn_fx[sec] == true) then
			return
		end
		
		shoot_effect(wpn, sec)
		
		--printf("Shooting effect played for [%s]", sec)
	end
end

OriginalShoot = actor_effects.shoot_effect
function actor_effects.shoot_effect(sec)
    if get_config("recoil") then return end
    OriginalShoot(sec)
end

function update_settings()
    if get_config("recoil") then
		RegisterScriptCallback("actor_on_weapon_fired",Update_Shooting)
	else
		UnregisterScriptCallback("actor_on_weapon_fired",Update_Shooting)
	end
end

function on_game_start()
	RegisterScriptCallback("on_option_change",update_settings)
	update_settings()
end
