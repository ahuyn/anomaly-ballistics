get_config          = ballistics_mcm.get_config
print_dbg           = ballistics_mcm.print_dbg
npc_bone_mult       = ballistics_utils.npc_bone_mult
npc_bone_protection = ballistics_utils.npc_bone_protection
npc_bone_data       = ballistics_utils.npc_bone_data
play_particle       = ballistics_utils.play_particle
mutant_hp           = ballistics_utils.mutant_hp
mutant_prot_values  = ballistics_utils.mutant_prot_values
modify_bone         = ballistics_utils.modify_bone
modify_velocity     = ballistics_utils.modify_velocity
modify_distance     = ballistics_utils.modify_distance
get_cur_vel         = ballistics_utils.get_cur_vel
add_effect          = arti_timed_events.add_effect
math_floor          = math.floor
math_abs            = math.abs
math_random         = math.random

Bone_IDs            = ballistics_utils.Bone_IDs
head_bones          = ballistics_utils.head_bones
ini_ammo            = ballistics_utils.ini_ammo

local anims = {
    "norm_2_critical_hit_torso_0", -- good
    "norm_1_critical_hit_head_0", -- good
}

-- pulls custom ap and hit power values from code
function get_ammo_data(ammo_sec)
    if ini_ammo:section_exist(ammo_sec) then
        return {
            sec     = ammo_sec,
            k_hit   = ini_ammo:r_float_ex(ammo_sec, "k_hit") or SYS_GetParam(2, ammo_sec, "k_hit") or 1,
            k_ap    = ini_ammo:r_float_ex(ammo_sec, "k_ap") or SYS_GetParam(2, ammo_sec, "k_ap") or 0,
            k_pen   = ini_ammo:r_float_ex(ammo_sec, "k_pen") or 0,
        }
    end
end

-- deal residual impact damage only
function impact(diff, ap_frac, pen)
    print_dbg("Impact")
    return 1 / (10 * (diff - 2))
end

-- reduction based on AP frac and diff
function reduce(diff, ap_frac, pen)
    local modifier =  1 - (0.3 * (1 + diff - ap_frac))
    print_dbg("Reduction of %s", modifier)
    return modifier
end

-- deal full damage (does nothing lol)
function full(diff, ap_frac, pen)
    print_dbg("Full")
    return 1
end

-- overpenetrate and lose damage (based on diff and pen)
-- default is reducing down to pen 
-- only matters if diff > 3, or more than 0.2
function penetrate(diff, ap_frac, pen)
    adj = pen * (diff - 3)/4
    print_dbg("Overkill, reduce by %s", adj)
    return 1 - adj
end

local damage_subcalcs = {
    [-7] = impact,
    [-6] = impact,
    [-5] = impact,
    [-4] = impact,
    [-3] = impact,
    [-2] = reduce,
    [-1] = reduce,
    [0] = reduce,
    [1] = full,
    [2] = full,
    [3] = full,
    [4] = penetrate,
    [5] = penetrate,
    [6] = penetrate,
    [7] = penetrate,
}

-- input: 
function tbl_reduce(x)
    local acc = 1
    for k,v in pairs(x) do
        -- print_dbg("Applying key %s, val %s", k ,v)
        acc = acc * v
    end
    return acc
end

function get_tier(val)
    return clamp(math_floor(val * 20), 0, 7)
end

function get_frac(val)
    frac = math.fmod(val * 20, 1)
    if frac > 0.9 then frac = 1 end
    return frac
end

--[[
    precalculate all the crap we need
    returns:
    {
        ammo_data: data on ammo (sec, overridden values for hit and ap)
        bone_data: data on bones (bone id, name, bone armor, if it's been modified, etc)
    }
]]
function prework(npc, s_hit, ctx)
    local precalc = {}
    
    precalc.base_power = ui_wpn_params.read_float(ctx.hit_data.wpn_sec, "", "hit_power")
    precalc.ammo_data = get_ammo_data(ctx.hit_data.ammo)
    precalc.bone_data = ctx.is_npc and npc_bone_data(npc, ctx.bone_id) or mutant_prot_values(npc, ctx.bone_id)

    return precalc
end

function apply_std_calcs(tbl, npc, s_hit, precalc)
    tbl.base_power = precalc.base_power
    ammo_data = precalc.ammo_data
    bone_data = precalc.bone_data
    tbl.k_hit = ammo_data.k_hit
    tbl.velocity = modify_velocity()
    tbl.distance = modify_distance(s_hit.draftsman, npc, ammo_data.sec)
    tbl.bone_mult = bone_data.mult
    -- local mod = ammo_data.k_hit * modify_velocity() * modify_distance(s_hit.draftsman, npc, ammo_data.sec) * bone_data.mult
    -- print_dbg("Applying standard modifier %s", mod)
    -- return mod
end

function process_hp(precalc, is_npc)
    local hp_mult = ini_ammo:r_float_ex(precalc.ammo_data.sec, "k_hp") 
    if not hp_mult then return 1 end
    -- mutants get partial hp expansion
    if not is_npc then
        local ap = precalc.ammo_data.k_ap * 2
        local armor = clamp(precalc.bone_data.armor - 0.25, 0, 1)
        -- based on ap difference, reduce hp mult in 30% increments
        diff = math_floor(20 * (ap - armor))
        hp_frac = hp_mult - 1
        modifier = 1 + (diff * 0.3)
        if diff < 0 then hp_mult = 1 + (hp_frac * modifier) end
        return hp_mult
    else
        if  precalc.ammo_data.k_ap >= precalc.bone_data.armor then return hp_mult end
    end
    return 1
end

function npc_standard(precalc)
    ammo_data = precalc.ammo_data
    bone_data = precalc.bone_data
    print_dbg("[NPC] Ammo %s: Hit %s, AP %s. Bone: ID %s, Armor %s", ammo_data.sec, ammo_data.k_hit, ammo_data.k_ap, bone_data.id, bone_data.armor)
    
    local armor_tier = get_tier(precalc.bone_data.armor)
    local ap_tier = get_tier(precalc.ammo_data.k_ap)
    local ap_frac = get_frac(precalc.ammo_data.k_ap)

    local diff = ap_tier - armor_tier
    -- ensure hp rounds dont overpen
    local hp_mult = ini_ammo:r_float_ex(ammo_data.sec, "k_hp") or 1
    if hp_mult > 1 then diff = clamp(diff, -7, 3) end
    -- print_dbg("Difference of %s, AP fraction of %s", diff, ap_frac)
    return damage_subcalcs[diff](math_abs(diff), ap_frac, ammo_data.k_pen)
end

function mutant_standard(precalc)
    ammo_data = precalc.ammo_data
    bone_data = precalc.bone_data
    print_dbg("[MUT] Ammo %s: Hit %s, AP %s. Bone: ID %s, Armor %s", ammo_data.sec, ammo_data.k_hit, ammo_data.k_ap, bone_data.id, bone_data.armor)
    
    local ap_val = ammo_data.k_ap * 2
    if ap_val > bone_data.armor then
        return clamp((ap_val - bone_data.armor)/ap_val, bone_data.hit_fraction, 1)
    else
        return bone_data.hit_fraction
    end
end

-- flinch applies up to 3 levels above the tier
function process_flinch(npc, precalc)
    local ammo_data = precalc.ammo_data
    local bone_data = precalc.bone_data
    if not ini_ammo:r_bool_ex(ammo_data.sec, "flinch") then return end
    ap_tier = get_tier(ammo_data.k_ap)
    armor_tier = get_tier(bone_data.armor)
    local flinch_adj = (ap_tier - armor_tier) * 0.3
    local flinch_chance =  clamp(0.9 - flinch_adj, 0, 1)
    -- print_dbg("Stagger adj %s, chance %s", flinch_adj, flinch_chance)
    if flinch_chance > 0 and math_random() < flinch_chance then
        -- print_dbg("Staggering NPC")
        play_anim(npc)
    end
end

function play_anim(npc)
    if npc:movement_type() == move.walk or npc:movement_type() == move.run then
        npc:set_movement_type(move.stand)
    end
    npc:play_cycle(anims[math_random(#anims)], true)
end

-- refer to ballistics_mcm.txt for logic details
-- handles basic bullets, flinching and hollowpoint expansion
function ballistic_handlers.default(npc, s_hit, ctx)
    local calcs = {}
    local precalc = prework(npc, s_hit, ctx)
    
    -- add standard calcs for hit, bone mult, etc
    apply_std_calcs(calcs, npc, s_hit, precalc)

    if not ctx.is_npc then
        calcs.ap_calc = mutant_standard(precalc)
    else
        -- tier based formula with overpen, and flinch
        calcs.ap_calc = npc_standard(precalc)
        process_flinch(npc, precalc)
    end
    calcs.hollowpoint =  process_hp(precalc, ctx.is_npc)

    local final_hit = tbl_reduce(calcs)
    print_dbg("Bone: %s. BA: %s. BM: %s. AP: %s. Vis: %s. Original: %s. Base hit: %s. Final hit: %s", bone_data.name, bone_data.armor, bone_data.mult, ammo_data.k_ap, npc:get_visual_name(), s_hit.power, calcs.base_power, final_hit)
    s_hit.power = final_hit
    return s_hit
end

local limbs = {
    [3]  = "bip01_l_thigh",
    [4]  = "bip01_l_calf",
    [5]  = "bip01_l_foot",
	[6]  = "bip01_l_toe0", 
    [7]  = "bip01_r_thigh",
    [8]  = "bip01_r_calf",
    [9]  = "bip01_r_foot",
	[10] = "bip01_r_toe0", 
	[21] = "bip01_l_upperarm", 
	[22] = "bip01_l_forearm", 
	[23] = "bip01_l_hand", 
	[24] = "bip01_l_finger0", 
	[25] = "bip01_l_finger01", 
	[26] = "bip01_l_finger02", 
	[27] = "bip01_l_finger1", 
	[28] = "bip01_l_finger11", 
	[29] = "bip01_l_finger12", 
	[30] = "bip01_l_finger2", 
	[31] = "bip01_l_finger21", 
	[32] = "bip01_l_finger22", 
	[34] = "bip01_r_upperarm", 
	[35] = "bip01_r_forearm", 
	[36] = "bip01_r_hand", 
	[37] = "bip01_r_finger0", 
	[38] = "bip01_r_finger01", 
	[39] = "bip01_r_finger02", 
	[40] = "bip01_r_finger1", 
	[41] = "bip01_r_finger11", 
	[42] = "bip01_r_finger12", 
	[43] = "bip01_r_finger2", 
	[44] = "bip01_r_finger21", 
	[45] = "bip01_r_finger22", 
}

-- buckshot ignores up to 20 armor on limb hit
function buckshot_damage(npc, s_hit, ctx)
    if not ctx.is_npc or not limbs[ctx.bone_id] then 
        s_hit = ballistic_handlers.default(npc, s_hit, ctx)
    else
        local calcs = {}
        local precalc = prework(npc, s_hit, ctx)
        bone_data = precalc.bone_data
        ammo_data = precalc.ammo_data
        -- reduce armor
        bone_data.armor = clamp(bone_data.armor - 0.2, 0, 1)
        
        calcs.base_power = precalc.base_power
    
        apply_std_calcs(calcs, npc, s_hit, precalc)
        calcs.ap_calc = npc_standard(precalc)

        local final_hit = tbl_reduce(calcs)
        print_dbg("Bone: %s. BA: %s. BM: %s. AP: %s. Vis: %s. Original: %s. Base hit: %s. Final hit: %s", bone_data.name, bone_data.armor, bone_data.mult, ammo_data.k_ap, npc:get_visual_name(), s_hit.power, calcs.base_power, final_hit)
        s_hit.power = final_hit
    end
    return s_hit
end

-- slugs ignore up to 20 armor on headshot
function slug(npc, s_hit, ctx)
    if not ctx.is_npc then return ballistic_handlers.default(npc, s_hit, ctx) end
    local calcs = {}
    local precalc = prework(npc, s_hit, ctx)
    ammo_data = precalc.ammo_data
    bone_data = precalc.bone_data

    apply_std_calcs(calcs, npc, s_hit, precalc)

    -- ignore armor on headshot
    if head_bones[ctx.bone_id] then
        print_dbg("Stunning on headshot")
        bone_data.armor = clamp(bone_data.armor - 0.05, 0, 1)
        play_anim(npc)
    end

    calcs.ap_calc = npc_standard(precalc)

    local final_hit = tbl_reduce(calcs)
    print_dbg("Bone: %s. BA: %s. BM: %s. AP: %s. Vis: %s. Original: %s. Base hit: %s. Final hit: %s", bone_data.name, bone_data.armor, bone_data.mult, ammo_data.k_ap, npc:get_visual_name(), s_hit.power, calcs.base_power, final_hit)
    s_hit.power = final_hit
end

-- jfp headshots
function headshot(npc, s_hit, ctx)
    if not ctx.is_npc then return ballistic_handlers.default(npc, s_hit, ctx) end
    local calcs = {}
    local precalc = prework(npc, s_hit, ctx)
    ammo_data = precalc.ammo_data
    bone_data = precalc.bone_data

    apply_std_calcs(calcs, npc, s_hit, precalc)

    -- ignore armor on headshot, set armor to one below ap to guarantee full damage
    if head_bones[ctx.bone_id] then
        print_dbg("Ignoring armor on headshot")
        bone_data.armor = clamp(ammo_data.k_ap - 0.05, 0, 1)
    end
    calcs.ap_calc = npc_standard(precalc)

    calcs.hollowpoint = process_hp(ctx.hit_data.ammo, ammo_data.k_ap, bone_data.armor, ctx.is_npc)

    local final_hit = tbl_reduce(calcs)
    print_dbg("Bone: %s. BA: %s. BM: %s. AP: %s. Vis: %s. Original: %s. Base hit: %s. Final hit: %s", bone_data.name, bone_data.armor, bone_data.mult, ammo_data.k_ap, npc:get_visual_name(), s_hit.power, calcs.base_power, final_hit)
    s_hit.power = final_hit
end

-- for 5.56 varmageddon
function varmageddon(npc, s_hit, ctx)
    s_hit = ballistic_handlers.default(npc, s_hit, ctx)
    if not ctx.is_npc then 
        -- varma mult always applies
        local v_mult = ini_ammo:r_float_ex(ammo_data.sec, "v_mult") or 1.5
        s_hit.power = s_hit.power * v_mult
    end
    return s_hit
end

local fire_eff = particles_object("artefact\\artefact_zharka")

-- ignite + reduce armor
function fire_damage(npc, s_hit, ctx)
    s_hit = fire_dot(npc, s_hit, ctx)
    -- shred 0.01 off each hit
    local bone_data = npc_bone_data(npc, ctx.bone_id)
    if ctx.is_npc then
        modify_bone(npc, ctx.bone_id, clamp(bone_data.armor - 0.03, 0, 1))
    end
    -- play something?
    return s_hit
end

-- ignite
function fire_dot(npc, s_hit, ctx)
    s_hit = ballistic_handlers.default(npc, s_hit, ctx)
    local ignite_chance = ini_ammo:r_float_ex(ctx.hit_data.ammo, "ignite") or 0
    if math_random() < ignite_chance then
        play_particle(npc, ctx.bone_id, "artefact\\af_thermal_idle")
        print_dbg("Ignited %s", npc:id())
        add_effect("ignite"..npc:id(), 5, 
        function()
            print_dbg("Burning %s", npc:id())
            fire_eff:play_at_pos(npc:position())
            if not npc:alive() then return end
            local h = hit()
            h.type = hit.fire
            h.draftsman = db.actor
            h.power = math.random(5, 10) / 100
            h.bone = "bip01_spine"
            npc:hit(h)
        end)
    end
    return s_hit
end

-- for corrosive ammo
function acid_damage(npc, s_hit, ctx)
    s_hit = ballistic_handlers.default(npc, s_hit, ctx)
    if not ctx.is_npc then return s_hit end
    -- shred ONCE per bone
    local bone_data = npc_bone_data(npc, ctx.bone_id)
    play_particle(npc, ctx.bone_id, "artefact\\effects\\af_acidic_idle_color")
    if not bone_data.modified then
        modify_bone(npc, ctx.bone_id, clamp(bone_data.armor * 0.6, 0, 1))
    end
    return s_hit
end

-- for 5.7 chaos sx
function chaos_damage(npc, s_hit, ctx)
    local calcs = {}
    local precalc = prework(npc, s_hit, ctx)
    ammo_data = precalc.ammo_data
    bone_data = precalc.bone_data

    -- these work for mutant or man
    apply_std_calcs(calcs, npc, s_hit, precalc)
    
    -- ap +/- 2 tiers randomly
    ammo_data.k_ap = clamp(ammo_data.k_ap + math_random()/9, 0, 1)
    if not ctx.is_npc then
        calcs.ap_calc = mutant_standard(precalc)
    else
        -- tier based formula with overpen, and flinch
        calcs.ap_calc = npc_standard(precalc)
    end

    calcs.chaos = 0.6 + math_random()
    
    local final_hit = tbl_reduce(calcs)
    print_dbg("Bone: %s. BA: %s. BM: %s. AP: %s. Vis: %s. Original: %s. Base hit: %s. Final hit: %s", bone_data.name, bone_data.armor, bone_data.mult, ammo_data.k_ap, npc:get_visual_name(), s_hit.power, calcs.base_power, final_hit)
    s_hit.power = final_hit
end

local effect = particles_object("artefact\\effects\\af_electra_show_flash_00")
-- for shock anti armor
function shock_damage(npc, s_hit, ctx)
    if not ctx.is_npc then return ballistic_handlers.default(npc, s_hit, ctx)
    end
    local calcs = {}
    local precalc = prework(npc, s_hit, ctx)
    
    local armor_tier = get_tier(precalc.bone_data.armor)

    apply_std_calcs(calcs, npc, s_hit, precalc)
    calcs.lightning_bonus = 1 + (armor_tier * 0.5)
    if armor_tier > 3 then
        play_particle(npc, ctx.bone_id, "amik\\anomaly\\electra\\electra_dust_distort")
        local h = hit()
        h.type = hit.shock
        h.draftsman = db.actor
        h.power = armor_tier * 0.15
        h.bone = "bip01_spine"
        radius = armor_tier / 2

        level.iterate_nearest(npc:position(), radius, function(obj)
            if obj and obj:alive() and obj:id() ~= AC_ID then
                obj:hit(h)
                effect:play_at_pos(obj:position())
            end
        end)
    end
    s_hit.power = tbl_reduce(calcs)
    return s_hit
end
-- spawn an explosive
function explosion(npc, s_hit, ctx)
    s_hit = ballistic_handlers.default(npc, s_hit, ctx)
    local npc_pos = npc:position()
    npc_pos.y = npc_pos.y + 0.5

    local explode_obj = alife_create_item("bullet_blow", {npc_pos, npc:level_vertex_id(), npc:game_vertex_id(), nil})
    CreateTimeEvent(explode_obj.id, explode_obj.id, 0, 
    function(id)
        local explode_obj = get_object_by_id(id)
        if explode_obj then
            explode_obj:explode(0)
            return true
        end
        return false
    end, explode_obj.id)
    return s_hit
end

