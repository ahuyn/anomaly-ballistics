get_config          = ballistics_mcm.get_config
print_dbg           = ballistics_mcm.print_dbg
npc_bone_mult       = ballistics_utils.npc_bone_mult
npc_bone_protection = ballistics_utils.npc_bone_protection
npc_bone_data       = ballistics_utils.npc_bone_data
modify_bone         = ballistics_utils.modify_bone
modify_velocity     = ballistics_utils.modify_velocity
get_cur_vel         = ballistics_utils.get_cur_vel
math_floor          = math.floor
math_abs            = math.abs

ini_ammo            = ballistics_utils.ini_ammo

local anims = {
    "norm_2_critical_hit_torso_0", -- good
    "norm_1_critical_hit_head_0", -- good
}

-- pulls custom ap and hit power values from code
function get_ammo_data(ammo_sec)
    if ini_ammo:section_exist(ammo_sec) then
        return {
            sec     = ammo_sec,
            k_hit   = ini_ammo:r_float_ex(ammo_sec, "k_hit") or SYS_GetParam(2, ammo_sec, "k_hit") or 1,
            k_ap    = ini_ammo:r_float_ex(ammo_sec, "k_ap") or SYS_GetParam(2, ammo_sec, "k_ap") or 0,
            k_pen   = ini_ammo:r_float_ex(ammo_sec, "k_pen") or 0.5,
        }
    end
end

-- deal residual impact damage only
function impact(base_hp, diff, ap_frac, pen)
    printf("Impact")
    return base_hp / (10 * (diff - 2))
end

-- reduction based on AP frac and diff
function reduce(base_hp, diff, ap_frac, pen)
    local modifier =  1 - (0.3 * (1 + diff - ap_frac))
    printf("Reduction of %s", modifier)
    return base_hp * modifier
end

-- deal full damage (does nothing lol)
function full(base_hp, diff, ap_frac, pen)
    printf("Full")
    return base_hp
end

-- overpenetrate and lose damage (based on diff and pen)
-- default is reducing down to pen 
function penetrate(base_hp, diff, ap_frac, pen)
    printf("Overkill")
    loss = 1 - pen
    adj = (diff - 3)/4
    return base_hp * (1 - (loss * adj))
end

local damage_subcalcs = {
    [-7] = impact,
    [-6] = impact,
    [-5] = impact,
    [-4] = impact,
    [-3] = impact,
    [-2] = reduce,
    [-1] = reduce,
    [0] = reduce,
    [1] = full,
    [2] = full,
    [3] = full,
    [4] = penetrate,
    [5] = penetrate,
    [6] = penetrate,
    [7] = penetrate,
}

--[[
    precalculate all the crap we need
    returns:
    {
        ammo_data: data on ammo (sec, overridden values for hit and ap)
        bone_data: data on bones (bone id, name, bone armor, if it's been modified, etc)
    }
]]
function prework(npc, s_hit, ctx)
    local precalc = {}
    
    precalc.base_power = ui_wpn_params.read_float(ctx.hit_data.wpn_sec, "", "hit_power")
    precalc.ammo_data = get_ammo_data(ctx.hit_data.ammo)
    precalc.bone_data = npc_bone_data(npc, ctx.bone_id)

    precalc.armor_tier = clamp(math_floor(bone_data.armor * 20), 0, 7)

    precalc.ap = {}
    local ap_rounded = ammo_data.k_ap * 20
    precalc.ap.ap_tier = math_floor(ap_rounded)
    local ap_frac = math.fmod(ap_rounded,1)
    if ap_frac > 0.9 then ap_frac = 1 end
    precalc.ap.ap_frac = ap_frac

    return precalc
end

-- refer to ballistics_mcm.txt for logic details
function ballistic_handlers.default(npc, s_hit, ctx)
    if not ctx.is_npc then return s_hit end

    local precalc = prework(npc, s_hit, ctx)
    ammo_data = precalc.ammo_data
    bone_data = precalc.bone_data
    ap = precalc.ap

    local base_hp = precalc.base_power

    base_hp = base_hp * ammo_data.k_hit
    -- modify by velocity
    base_hp = base_hp * modify_velocity(s_hit.draftsman, npc, ammo_data.sec)

    local diff = ap.ap_tier - precalc.armor_tier
    printf("Difference of %s, AP fraction of %s", diff, ap.ap_frac)
    base_hp = damage_subcalcs[diff](base_hp, math_abs(diff), ap.ap_frac, ammo_data.k_pen)

    -- hollowpoints (we only deal expansive bonus dmg on penetration)
    local hp_mult = ini_ammo:r_float_ex(hit_data.ammo, "k_hp") or 1
    if hp_mult > 1 and diff >= 0 then
        print_dbg("Applying HP multiplier of %s", hp_mult)
        base_hp = base_hp * hp_mult
    end

    local flinch_chance = ini_ammo:r_float_ex(hit_data.ammo, "flinch") or 0
    -- softpoint bullets only 
    if flinch_chance > 0 and diff >= 0 and math.random() < flinch_chance then
        print_dbg("Staggering NPC")
        if npc:movement_type() == move.walk or npc:movement_type() == move.run then
            npc:set_movement_type(move.stand)
        end
        npc:play_cycle(anims[math.random(#anims)], true)
    end

    -- Apply bone mult
    base_hp = base_hp * bone_data.mult

    print_dbg("Bone: %s. BA: %s. BM: %s. AP: %s. Vis: %s. Original: %s. Base hit: %s. Final hit: %s", bone_data.name, bone_data.armor, bone_data.mult, ammo_data.k_ap, npc:get_visual_name(), s_hit.power, base_power, base_hp)
    s_hit.power = base_hp
    return s_hit
end

local limbs = {
    [3]  =	"bip01_l_thigh",
    [4]  =	"bip01_l_calf",
    [5]  =	"bip01_l_foot",
    [7]  =	"bip01_r_thigh",
    [8]  =	"bip01_r_calf",
    [9]  =	"bip01_r_foot",
    [21] =	"bip01_l_upperarm",
    [22] =	"bip01_l_forearm",
    [23] =	"bip01_l_forearm",
    [34] =	"bip01_r_upperarm",
    [35] =	"bip01_r_forearm",
    [36] =	"bip01_r_forearm",
}

-- buckshot has slightly different impact calculations
function buckshot_damage(npc, s_hit, ctx)
    s_hit = ballistic_handlers.default(npc, s_hit, bone_id, hit_data, is_human)
    -- deal extra damage to limbs if applicable
    if limbs[ctx.bone_id] then
        s_hit.power = s_hit.power * 1.5
    end
    return s_hit
end

-- for shit that shreds armor
function shred_damage(npc, s_hit, ctx)
    s_hit = ballistic_handlers.default(npc, s_hit, bone_id, hit_data, is_human)
    -- shred 0.01 off each hit
    local bone_data = npc_bone_data(npc, bone_id)
    modify_bone(npc, bone_id, clamp(bone_data.armor - 0.01, 0, 1))
    -- play something?
    return s_hit
end

-- for corrosive ammo
function acid_damage(npc, s_hit, ctx)
    s_hit = ballistic_handlers.default(npc, s_hit, bone_id, hit_data, is_human)
    -- shred 0.1 ONCE per bone
    local bone_data = npc_bone_data(npc, bone_id)
    if not bone_data.modified then
        modify_bone(npc, bone_id, clamp(bone_data.armor - 0.1, 0, 1))
        -- play something?
    end
    return s_hit
end

function chaos_damage(npc, s_hit, ctx)
    s_hit = ballistic_handlers.default(npc, s_hit, bone_id, hit_data, is_human)
    s_hit = s_hit * (0.6 + math.random())
    return s_hit
end

-- loadout stuff

local clr_1  = utils_xml.get_color("ui_gray_1")
local clr_2  = utils_xml.get_color("ui_gray_2")
local clr_p  = utils_xml.get_color("d_purple")
gc = game.translate_string
BuildFooter = ui_item.build_desc_footer
function ui_item.build_desc_footer(obj, sec, str)
    _str = BuildFooter(obj, sec, str)
    sec = obj and obj:section() or sec
    if ini_ammo:section_exist(sec) and ini_ammo:r_string_ex(sec, "name") then
        local ammo_data = get_ammo_data(sec)
        local str_dmg = math_floor(ammo_data.k_hit * 100) .. "%"
        local str_ap = gc("st_prop_armor_".. math_floor(ammo_data.k_ap * 20))
        local str_impair = math.floor(100 * (ini_ammo:r_float_ex(sec, "impair") or 1)) .. "%"
        local str_spec = ini_ammo:r_string_ex(sec, "special")
        if str_spec then str_spec = str_explode(str_spec, ",") 
        else str_spec = {} end

        _str = _str .. "\\n" .. gc("st_ball_properties") .. "\\n"
        _str = _str .. " " .. clr_p .. gc("st_dot") .. " " .. clr_2 .. gc("st_prop_k_hit") .. " " .. clr_1 .. str_dmg .. "\\n"
        _str = _str .. " " .. clr_p .. gc("st_dot") .. " " .. clr_2 .. gc("st_prop_k_ap") .. " " .. clr_1 .. str_ap .. "\\n"
        _str = _str .. " " .. clr_p .. gc("st_dot") .. " " .. clr_2 .. gc("st_prop_impair") .. " " .. clr_1 .. str_impair .. "\\n"
        for k,v in pairs(str_spec) do        
            _str = _str .. " " .. clr_p .. gc("st_dot") .. " " .. clr_2 .. gc("st_ballistics_"..v) .. " " .. "\\n"
        end
    end
    return _str
end