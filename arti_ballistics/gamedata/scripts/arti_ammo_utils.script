
math_random         = math.random
math_floor          = math.floor
gc                  = game.translate_string
ini_ammo            = ballistics_utils.ini_ammo
get_ammo_data       = arti_handlers.get_ammo_data
print_dbg           = ballistics_mcm.print_dbg

local modes = {
	["inventory"] = true,
}
local bags = {
	["actor_bag"] = true,
	["actor_equ"] = true,
	["actor_belt"] = true,
}
function try_mg_link(obj, bag, mode)
    if obj and bags[bag] and modes[mode] then
        if obj:section() == "ammo_7.62x54_7h1" then
            return gc("st_link")
        elseif obj:section() == "ammo_pkm_100" then
            return gc("st_unlink")
        end
    end
end

function mg_link(obj)
    -- grab up to 5 and try to link them together
    if obj:section() ==  "ammo_7.62x54_7h1" then
        local to_link = {}
        local count = 0
        db.actor:iterate_inventory(function(npc, item)
            if item:section() == "ammo_7.62x54_7h1" and count < 5 then
                to_link[item:id()] = item
                count = count + 1
            end
        end)
        local total = 0
        for k,v in pairs(to_link) do
            total = total + v:ammo_get_count()
            alife_release_id(k)
        end
        if total > 0 then
            alife_create_item("ammo_pkm_100", db.actor, {ammo = total})
        end
    elseif obj:section() == "ammo_pkm_100" then
        local count = obj:ammo_get_count()
        create_ammo("ammo_7.62x54_7h1", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID, count)
        alife_release(obj)
    end
end

function downgrade_ammo(sec, bypass)
    print_dbg("Try downgrade ammo %s", sec)
    local dg_ammo = ini_ammo:r_string_ex(sec, "dg_ammo")
    local dg_chance = ini_ammo:r_float_ex(sec, "dg_chance") or 0
    if dg_ammo and (math_random() < dg_chance or bypass) then
        print_dbg("Downgrading ammo %s to %s", sec, dg_ammo)
        return dg_ammo
    else 
        return sec
    end
end

function process_wpn(wpn, bypass)
    local ammo_data = utils_item.get_ammo(wpn:section(), wpn:id())
    local ammo_data_key = utils_item.get_ammo(wpn:section(), wpn:id(), true)
    if is_empty(ammo_data) then return end
    local ammo_type = ammo_data[wpn:get_ammo_type() + 1]
    local dg_ammo = ini_ammo:r_string_ex(ammo_type, "dg_ammo") or ""
    local dg_chance = ini_ammo:r_float_ex(ammo_type, "dg_chance") or 0
    if ammo_data_key[dg_ammo] and (bypass or math_random() < dg_chance) then
        print_dbg("Downgrading ammo for weapon %s", wpn:section())
        wpn:set_ammo_type(wpn:get_ammo_type() - 1)
    end
end


TraderAuto = trader_autoinject.update
function trader_autoinject.update(npc)
    TraderAuto(npc)
    to_create = {}
    npc:iterate_inventory(function(npc, item)
        local sec = item:section()
        dg = downgrade_ammo(sec)
        if sec ~= dg then
            to_create[item:id()] = {
                sec = dg,
                cnt = item:ammo_get_count()
            }
        end

    end)
    for k,v in pairs(to_create) do
        alife_release_id(k)
        alife_create_item(v.sec, npc, {ammo = v.cnt})
    end
end

local item_count = {}

function death_manager.try_spawn_ammo(npc)
	local ammo_class,sec,number
	local function itr(npc,itm)
		if (IsWeapon(nil,itm:clsid()) and not npc:marked_dropped(itm)) then
			ammo_class = parse_list(ini_sys,itm:section(),"ammo_class")
			
			-- randomly spawn only 1 ammo type per found weapon
			if (#ammo_class > 0) then
				sec = ammo_class[math.random(1,#ammo_class)]
				if (sec) then 
                    sec = downgrade_ammo(sec)
					if (item_count[sec]) then
						number = math.random(item_count[sec][1], item_count[sec][2])
					else 
						number = 0
					end
					if (number > 0 and ini_sys:section_exist(sec)) then
						alife_create_item(sec, npc, {ammo = number})
					end
				end
			end
			
			-- spawn grenade ammo if there is launcher attached
			if (ini_sys:r_float_ex(itm:section(),"grenade_launcher_status") > 0) then
				ammo_class = parse_list(ini_sys,itm:section(),"grenade_class")
				for i=1,#ammo_class do
					sec = ammo_class[i]
					if (sec) then
						if (item_count[sec]) then
							number = math.random(item_count[sec][1], item_count[sec][2])
						else 
							number = math.random(0,2)
						end
						if (number > 0 and ini_sys:section_exist(sec)) then 
							alife_create_item(sec, npc, {ammo = number})
						end
					end
				end
			end
		end
	end
	npc:iterate_inventory(itr,npc)
	
	CreateTimeEvent(npc:id(), "npc_ammo_aggregation", 0, item_weapon.ammo_aggregation_full, npc:id())
end
-- alife_create_orig = _G.alife_create_item
-- function _G.alife_create_item(sec, npc, data)
--     if ini_ammo:section_exist(sec) then
--         sec = downgrade_ammo(sec)
--     end
--     return alife_create_orig(sec, npc, data)
-- end

-- loadout stuff

local clr_1  = utils_xml.get_color("ui_gray_1")
local clr_2  = utils_xml.get_color("ui_gray_2")
local clr_p  = utils_xml.get_color("d_purple")
gc = game.translate_string
BuildFooter = ui_item.build_desc_footer
function ui_item.build_desc_footer(obj, sec, str)
    _str = BuildFooter(obj, sec, str)
    sec = obj and obj:section() or sec
    if ini_ammo:section_exist(sec) and ini_ammo:r_string_ex(sec, "name") then
        local ammo_data = get_ammo_data(sec)
        local str_dmg = math_floor(ammo_data.k_hit * 100) .. "%"
        local str_ap = gc("st_prop_armor_".. math_floor(ammo_data.k_ap * 20))
        local str_impair = math.floor(100 * (ini_ammo:r_float_ex(sec, "impair") or 1)) .. "%"
        local str_spec = ini_ammo:r_string_ex(sec, "special")
        if str_spec then str_spec = str_explode(str_spec, ",") 
        else str_spec = {} end

        _str = _str .. "\\n \\n" .. gc("st_ball_properties") .. "\\n \\n"
        _str = _str .. " " .. clr_p .. gc("st_dot") .. " " .. clr_2 .. gc("st_prop_k_hit") .. " " .. clr_1 .. str_dmg .. "\\n"
        _str = _str .. " " .. clr_p .. gc("st_dot") .. " " .. clr_2 .. gc("st_prop_k_ap") .. " " .. clr_1 .. str_ap .. "\\n"
        _str = _str .. " " .. clr_p .. gc("st_dot") .. " " .. clr_2 .. gc("st_prop_impair") .. " " .. clr_1 .. str_impair .. "\\n"
        for k,v in pairs(str_spec) do        
            _str = _str .. " " .. clr_p .. gc("st_dot") .. " " .. clr_2 .. gc("st_ballistics_"..v) .. " " .. "\\n"
        end
    end
    return _str
end



function on_game_start()
    local n = itms_manager.ini_death:line_count("item_count")
	local id, value = "", ""
	for i=0,n-1 do
		local result, id, value	= itms_manager.ini_death:r_line_ex("item_count",i,"","")
		local p = str_explode(value,",")
		if (p) then
			p[1] = tonumber(p[1]) or 0
			p[2] = tonumber(p[2]) or p[1]
			item_count[id] = {math.ceil(p[1]),math.ceil(p[2])}
		end
	end
	custom_functor_autoinject.add_functor("mg_link", try_mg_link, try_mg_link, nil, mg_link, true)
end